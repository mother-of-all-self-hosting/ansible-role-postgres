---
- name: Ensure Postgres service is started
  ansible.builtin.service:
    name: "{{ postgres_identifier }}"
    state: started
    daemon_reload: true
  register: postgres_ensure_started_result

- name: Wait a bit, so that Postgres can start
  when: postgres_ensure_started_result.changed | bool
  ansible.builtin.wait_for:
    timeout: "{{ postgres_managed_databases_postgres_start_wait_timeout_seconds }}"
  delegate_to: 127.0.0.1
  become: false

# If Postgres is up from before, but it had originally been installed on a different container network,
# trying to prepare databases by connecting to `postgres_container_network` would fail.
# For this reason, we determine and use the currently used network.
# Restarting the service later would put it in the current network.
- name: Check Postgres container network
  ansible.builtin.command: "{{ devture_systemd_docker_base_host_command_docker }} container inspect {{ postgres_identifier }} --format '{% raw %}{{.HostConfig.NetworkMode}}{% endraw %}'"
  register: postgres_container_network_check_result
  changed_when: false

- name: Set Postgres container network to use for preparing databases
  ansible.builtin.set_fact:
    postgres_container_network_for_preparing_databases: "{{ postgres_container_network_check_result.stdout }}"

- name: Fail if managed database data appears invalid
  ansible.builtin.fail:
    msg: "Managed database definition ({{ item }}) lacks required keys: {{ missing_keys | join(', ') }}"
  loop: "{{ postgres_managed_databases }}"
  loop_control:
    loop_var: item
  vars:
    missing_keys: "{{ ['name', 'username', 'password'] | difference(item.keys() | list) }}"
  when: missing_keys | length > 0

- name: Fetch existing Postgres roles
  ansible.builtin.command:
    cmd: >-
      {{ devture_systemd_docker_base_host_command_docker }} run
      --rm
      --user={{ postgres_container_uid }}:{{ postgres_container_gid }}
      {% if postgres_container_cap_drop_all_enabled %}
      --cap-drop=ALL
      {% endif %}
      --env-file={{ postgres_base_path }}/env-postgres-psql
      --network={{ postgres_container_network_for_preparing_databases }}
      --entrypoint=psql
      {{ postgres_container_image_to_use }}
      -h {{ postgres_connection_hostname }} -tA -c "SELECT rolname FROM pg_roles" postgres
  register: postgres_existing_roles_result
  changed_when: false

- name: Fetch existing Postgres databases
  ansible.builtin.command:
    cmd: >-
      {{ devture_systemd_docker_base_host_command_docker }} run
      --rm
      --user={{ postgres_container_uid }}:{{ postgres_container_gid }}
      {% if postgres_container_cap_drop_all_enabled %}
      --cap-drop=ALL
      {% endif %}
      --env-file={{ postgres_base_path }}/env-postgres-psql
      --network={{ postgres_container_network_for_preparing_databases }}
      --entrypoint=psql
      {{ postgres_container_image_to_use }}
      -h {{ postgres_connection_hostname }} -tA -c "SELECT datname FROM pg_database" postgres
  register: postgres_existing_databases_result
  changed_when: false

- name: Normalize existing Postgres roles and databases
  ansible.builtin.set_fact:
    postgres_existing_roles: >-
      {{
        postgres_existing_roles_result.stdout_lines
        | default([])
        | map('trim')
        | reject('equalto', '')
        | list
      }}
    postgres_existing_databases: >-
      {{
        postgres_existing_databases_result.stdout_lines
        | default([])
        | map('trim')
        | reject('equalto', '')
        | list
      }}

- name: Determine which managed databases require initialization
  ansible.builtin.set_fact:
    postgres_managed_db_needs_init_map: >-
      {%- set m = {} -%}
      {%- for db in postgres_managed_databases -%}
      {%- set _ = m.update({db.name: ((db.username not in postgres_existing_roles) or (db.name not in postgres_existing_databases))}) -%}
      {%- endfor -%}
      {{ m }}


- name: Collect managed databases which require initialization
  ansible.builtin.set_fact:
    postgres_managed_databases_to_init: >-
      {{
        postgres_managed_databases
        | selectattr('name', 'in', (postgres_managed_db_needs_init_map | dict2items | selectattr('value', 'equalto', true) | map(attribute='key') | list))
        | list
      }}


- name: Create managed database initialization SQL file
  ansible.builtin.template:
    src: "{{ role_path }}/templates/sql/init-managed-dbs-user-and-role.sql.j2"
    dest: "/tmp/{{ postgres_identifier }}-init-managed-dbs-user-and-role.sql"
    mode: "0600"
    owner: "{{ postgres_uid }}"
    group: "{{ postgres_gid }}"
  when: postgres_managed_databases_to_init | length > 0


- name: Execute Postgres managed database initialization SQL file
  ansible.builtin.command:
    cmd: >-
      {{ devture_systemd_docker_base_host_command_docker }} run
      --rm
      --user={{ postgres_container_uid }}:{{ postgres_container_gid }}
      {% if postgres_container_cap_drop_all_enabled %}
      --cap-drop=ALL
      {% endif %}
      --env-file={{ postgres_base_path }}/env-postgres-psql
      --network={{ postgres_container_network_for_preparing_databases }}
      --mount type=bind,src=/tmp/{{ postgres_identifier }}-init-managed-dbs-user-and-role.sql,dst=/{{ postgres_identifier }}-init-managed-dbs-user-and-role.sql,ro
      --entrypoint={{ postgres_container_shell_path }}
      {{ postgres_container_image_to_use }}
      -c
      'psql -h {{ postgres_connection_hostname }} --file=/{{ postgres_identifier }}-init-managed-dbs-user-and-role.sql'
  changed_when: true
  when: postgres_managed_databases_to_init | length > 0

- name: Delete managed database initialization SQL file
  ansible.builtin.file:
    path: /tmp/{{ postgres_identifier }}-init-managed-dbs-user-and-role.sql
    state: absent
  when: postgres_managed_databases_to_init | length > 0

- name: Ensure Postgres is stopped, if it originally was and if we are configured to do it
  when: postgres_systemd_service_stop_originally_stopped_after_preparation | bool and postgres_ensure_started_result.changed | bool
  ansible.builtin.service:
    name: "{{ postgres_identifier }}"
    state: stopped
