---
# Pre-checks

# Defaults

- name: Set postgres_start_wait_time, if not provided
  ansible.builtin.set_fact:
    postgres_start_wait_time: 15
  when: "postgres_start_wait_time | default('') == ''"

- name: Set postgres_vacuum_wait_time, if not provided
  ansible.builtin.set_fact:
    postgres_vacuum_wait_time: "{{ 7 * 86400 }}"
  when: "postgres_vacuum_wait_time | default('') == ''"

- name: Set postgres_vacuum_databases_list, if not provided
  ansible.builtin.set_fact:
    postgres_vacuum_databases_list: "{{ postgres_vacuum_default_databases_list }}"
  when: "postgres_vacuum_databases_list | default([]) | length == 0"

- name: Set postgres_vacuum_preset, if not provided
  ansible.builtin.set_fact:
    postgres_vacuum_preset: vacuum-complete
  when: "postgres_vacuum_preset | default('') == ''"

- name: Exit if postgres_vacuum_preset is unrecognized
  ansible.builtin.fail:
    msg: "Urecognized preset: {{ postgres_vacuum_preset }}"
  when: "postgres_vacuum_preset not in postgres_vacuum_presets.keys()"

- name: Set postgres_vacuum_stops_services, if not provided
  ansible.builtin.set_fact:
    postgres_vacuum_stops_services: "{{ postgres_vacuum_presets[postgres_vacuum_preset].stopsServices }}"
  when: "postgres_vacuum_stops_services | default('') == ''"

- name: Set postgres_vacuum_query, if not provided
  ansible.builtin.set_fact:
    postgres_vacuum_query: "{{ postgres_vacuum_presets[postgres_vacuum_preset].query }}"
  when: "postgres_vacuum_query | default('') == ''"

# Actual vacuuming work

- name: Ensure Postgres service is started
  ansible.builtin.service:
    name: "{{ postgres_identifier }}"
    state: started
    daemon_reload: true
  register: postgres_ensure_started_result

- name: Wait a bit, so that Postgres can start
  when: postgres_ensure_started_result.changed | bool
  ansible.builtin.wait_for:
    timeout: "{{ postgres_start_wait_time }}"
  delegate_to: 127.0.0.1
  become: false

- name: Detect existing Postgres version
  ansible.builtin.import_tasks: tasks/detect_existing_postgres_version.yml

- name: Abort, if no existing Postgres version detected
  ansible.builtin.fail:
    msg: "Could not find existing Postgres installation"
  when: "not postgres_detected_existing | bool"

- name: Ensure services are stopped before Postgres vacuuming, if necessary
  when: postgres_vacuum_stops_services | bool
  ansible.builtin.service:
    name: "{{ item }}"
    state: stopped
    daemon_reload: true
  with_items: "{{ postgres_systemd_services_to_stop_for_maintenance_list }}"

# If Postgres is up from before, but it had originally been installed on a different container network,
# trying to vacuum databases by connecting to `postgres_container_network` would fail.
# For this reason, we determine and use the currently used network.
# Restarting the service later would put it in the current network.
- name: Check Postgres container network
  ansible.builtin.command: "{{ devture_systemd_docker_base_host_command_docker }} container inspect {{ postgres_identifier }} --format '{% raw %}{{.HostConfig.NetworkMode}}{% endraw %}'"
  register: postgres_container_network_check_result
  changed_when: false

- name: Set Postgres container network to use for vacuuming databases
  ansible.builtin.set_fact:
    postgres_container_network_for_vacuuming: "{{ postgres_container_network_check_result.stdout }}"

- name: Generate Postgres database vacuum command
  ansible.builtin.set_fact:
    postgres_vacuum_run_command: >-
      {{ devture_systemd_docker_base_host_command_docker }} run
      --rm
      --name={{ postgres_identifier }}-vacuum
      --user={{ postgres_container_uid }}:{{ postgres_container_gid }}
      --cap-drop=ALL
      --network={{ postgres_container_network_for_vacuuming }}
      --env-file={{ postgres_base_path }}/env-postgres-psql
      {{ postgres_detected_version_corresponding_container_image }}
      /bin/sh -c 'for db in {{ postgres_vacuum_databases_list | join(" ") }}; do echo "VACUUM start: $db"; if ! psql -v ON_ERROR_STOP=1 -h {{ postgres_identifier }} "$db" -c "{{ postgres_vacuum_query }}"; then echo "VACUUM failed: $db"; exit 1; fi; echo "VACUUM done: $db"; done; echo "VACUUM completed for all databases"'

- name: Note about Postgres vacuum alternative
  ansible.builtin.debug:
    msg: >-
      Running vacuum against the databases `{{ postgres_vacuum_databases_list | join(", ") }}` with the following Postgres command:
      `{{ postgres_vacuum_run_command }}`.
      If this crashes, you can stop all processes which may use the database (`systemctl stop example.service another.service`),
      start Postgres only (`systemctl start {{ postgres_identifier }}`)
      and manually run the above command directly on the server.

- name: Run Postgres vacuum command
  ansible.builtin.command:
    cmd: "{{ postgres_vacuum_run_command }}"
  async: "{{ postgres_vacuum_wait_time }}"
  poll: "{{ postgres_vacuum_poll_interval }}"
  register: postgres_vacuum_result
  failed_when: not postgres_vacuum_result.finished or postgres_vacuum_result.rc != 0
  changed_when: postgres_vacuum_result.finished and postgres_vacuum_result.rc == 0

# Intentionally show the results
- ansible.builtin.debug:
    var: "postgres_vacuum_result"

- name: Ensure Postgres is stopped (if it previously was)
  when: postgres_ensure_started_result.changed | bool
  ansible.builtin.service:
    name: "{{ postgres_identifier }}"
    state: stopped

- name: Ensure services are started back up after Postgres vacuuming, if necessary
  when: postgres_vacuum_stops_services | bool
  ansible.builtin.service:
    name: "{{ item }}"
    state: started
    daemon_reload: true
  with_items: "{{ postgres_systemd_services_to_stop_for_maintenance_list }}"
